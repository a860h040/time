<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Method 1 Panel</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --panel:rgba(255,255,255,.04);
      --hair:rgba(255,255,255,.10);
      --hair2:rgba(255,255,255,.08);
      --text:#eaf0ff;
      --muted:rgba(234,240,255,.72);
      --accent:#5aa0ff;
      --ok:#2bd07e;
      --warn:#ffd166;
      --err:#ff6b6b;
      --radius:16px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:transparent;
      color:var(--text);
    }
    .panel{
      height:100%;
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .btn{
      appearance:none;
      border:1px solid rgba(90,160,255,.55);
      background:linear-gradient(180deg, rgba(90,160,255,.25), rgba(90,160,255,.10));
      color:var(--text);
      font-weight:800;
      letter-spacing:.2px;
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      transition:transform .08s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:active{ transform:translateY(1px); }
    .btn[disabled]{ opacity:.55; cursor:not-allowed; }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--hair2);
      background:var(--panel);
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background:var(--warn);
      box-shadow:0 0 0 4px rgba(255,209,102,.12);
      flex:0 0 auto;
    }
    .dot.ok{ background:var(--ok); box-shadow:0 0 0 4px rgba(43,208,126,.12); }
    .dot.err{ background:var(--err); box-shadow:0 0 0 4px rgba(255,107,107,.12); }

    .grid{
      display:grid;
      grid-template-columns:1fr;
      gap:10px;
      padding:10px;
      border:1px solid var(--hair);
      border-radius:var(--radius);
      background:rgba(255,255,255,.03);
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:8px 8px;
      border-radius:12px;
      background:rgba(0,0,0,.12);
      border:1px solid rgba(255,255,255,.06);
    }
    .k{
      font-size:12px;
      color:var(--muted);
      line-height:1.2;
    }
    .v{
      font-size:13px;
      font-weight:800;
      color:rgba(234,240,255,.95);
      text-align:right;
      word-break:break-word;
    }
    .minInput{
      width:120px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.22);
      color:var(--text);
      padding:10px 10px;
      font-weight:800;
      outline:none;
      text-align:right;
    }
    .minInput:focus{
      border-color:rgba(90,160,255,.55);
      box-shadow:0 0 0 4px rgba(90,160,255,.14);
    }
    .hint{
      font-size:11.5px;
      color:rgba(234,240,255,.60);
      line-height:1.35;
    }
    .hint a{ color:rgba(90,160,255,.95); text-decoration:none; }
    .hint a:hover{ text-decoration:underline; }

    #sourceFrame{
      position:absolute;
      left:-99999px; top:-99999px;
      width:1280px; height:720px;
      opacity:0;
      pointer-events:none;
      border:0;
    }
  </style>
</head>

<body>
  <div class="panel">
    <div class="top">
      <button class="btn" id="predictBtn" disabled>Load &amp; Predict</button>
      <div class="pill">
        <span class="dot" id="statusDot"></span>
        <span id="statusText">Loading source…</span>
      </div>
    </div>

    <div class="grid" aria-label="Method 1 Values">
      <div class="row">
        <div class="k">Min days after last sheet date</div>
        <input id="minDaysInput" class="minInput" type="number" inputmode="numeric" min="0" step="1" placeholder="e.g., 3" />
      </div>
      <div class="row">
        <div class="k">Time</div>
        <div class="v" id="time">—</div>
      </div>
      <div class="row">
        <div class="k">Price</div>
        <div class="v" id="price">—</div>
      </div>
    </div>

    <div class="hint">
      Source: <a href="https://a860h040.github.io/time/index1" target="_blank" rel="noopener">open Method 1 page</a>
    </div>
  </div>

  <iframe id="sourceFrame" title="Method 1 Source" src="about:blank"></iframe>

  <script>
    (function(){
      const METHOD = 'method1';
      const SOURCE_URL = 'https://a860h040.github.io/time/index1';

      const predictBtn = document.getElementById('predictBtn');
      const statusDot = document.getElementById('statusDot');
      const statusText = document.getElementById('statusText');

      const minDaysInput = document.getElementById('minDaysInput');
      const timeEl = document.getElementById('time');
      const priceEl = document.getElementById('price');

      const sourceFrame = document.getElementById('sourceFrame');

      function clean(s){ return String(s ?? '').replace(/\s+/g,' ').trim(); }
      function setStatus(state, text){
        statusText.textContent = text;
        statusDot.classList.remove('ok','err');
        if(state === 'ok') statusDot.classList.add('ok');
        if(state === 'err') statusDot.classList.add('err');
      }
      function post(msg){
        try{ window.parent.postMessage(msg, window.location.origin); }catch(_){}
      }
      function panelError(message){
        setStatus('err', message);
        predictBtn.disabled = true;
        post({ type:'panel_error', method: METHOD, message });
      }
      function canAccessFrame(){
        try{ return !!(sourceFrame.contentDocument && sourceFrame.contentDocument.body); }
        catch(e){ return false; }
      }
      function getDoc(){ return sourceFrame.contentDocument; }

      function isBetween(node, start, end){
        if(!node || !start) return false;
        const afterStart = !!(start.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_FOLLOWING);
        if(!afterStart) return false;
        if(!end) return true;
        const beforeEnd = !!(end.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_PRECEDING);
        return beforeEnd;
      }
      function leafTextValue(el){
        if(!el) return '';
        const tag = (el.tagName||'').toUpperCase();
        if(tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return clean(el.value);
        return clean(el.innerText);
      }
      function findHeadingContaining(doc, needle){
        const n = needle.toLowerCase();
        for(const h of doc.querySelectorAll('h1,h2,h3,h4,h5,h6')){
          const t = clean(h.innerText).toLowerCase();
          if(t.includes(n)) return h;
        }
        return null;
      }
      function findBoundaryHeading(doc, startHeading){
        const headings = Array.from(doc.querySelectorAll('h1,h2,h3,h4,h5,h6'));
        const startIdx = headings.indexOf(startHeading);
        if(startIdx < 0) return null;
        for(let i = startIdx + 1; i < headings.length; i++){
          const t = clean(headings[i].innerText).toLowerCase();
          if(/^4\)/.test(t) || t.includes('10-day price path') || t.includes('chart')) return headings[i];
        }
        return null;
      }
      function findLeafWithText(doc, needle, { exact=false, withinStart=null, withinEnd=null } = {}){
        const n = needle.toLowerCase();
        const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT, {
          acceptNode(node){
            const tag = (node.tagName||'').toUpperCase();
            if(tag === 'SCRIPT' || tag === 'STYLE' || tag === 'NOSCRIPT') return NodeFilter.FILTER_REJECT;
            if(withinStart && !isBetween(node, withinStart, withinEnd)) return NodeFilter.FILTER_SKIP;
            if(node.children && node.children.length) return NodeFilter.FILTER_SKIP;
            const t = clean(node.textContent).toLowerCase();
            if(!t) return NodeFilter.FILTER_SKIP;
            if(exact ? (t === n) : t.includes(n)) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
          }
        });
        let cur;
        while((cur = walker.nextNode())) return cur;
        return null;
      }
      function valueNearLabel(labelEl){
        if(!labelEl) return '';

        const tr = labelEl.closest && labelEl.closest('tr');
        if(tr){
          const cells = Array.from(tr.querySelectorAll('th,td'));
          if(cells.length >= 2){
            for(let i = cells.length - 1; i >= 0; i--){
              const v = leafTextValue(cells[i]);
              if(v && v !== leafTextValue(labelEl)) return v;
            }
          }
        }

        if(labelEl.nextElementSibling){
          const v = leafTextValue(labelEl.nextElementSibling);
          if(v) return v;
          const nested = labelEl.nextElementSibling.querySelector && labelEl.nextElementSibling.querySelector('input,textarea,select');
          if(nested){
            const vv = leafTextValue(nested);
            if(vv) return vv;
          }
        }

        const p = labelEl.parentElement;
        if(p){
          const kids = Array.from(p.children);
          const idx = kids.indexOf(labelEl);
          if(idx >= 0){
            for(let i = idx + 1; i < kids.length; i++){
              const v = leafTextValue(kids[i]);
              if(v && v !== leafTextValue(labelEl)) return v;
              const nested = kids[i].querySelector && kids[i].querySelector('input,textarea,select');
              if(nested){
                const vv = leafTextValue(nested);
                if(vv) return vv;
              }
            }
          }
        }
        return '';
      }

      function findLoadPredictButton(doc){
        const candidates = Array.from(doc.querySelectorAll('button,input[type="button"],input[type="submit"],a,[role="button"]'));
        for(const el of candidates){
          const t = clean((el.innerText || el.value || el.getAttribute('aria-label') || ''));
          const tl = t.toLowerCase();
          if(tl.includes('load') && tl.includes('predict')) return el;
        }
        return null;
      }

      // --- Min-days: find the actual input/control in the source page and set it ---
      function findMinDaysControl(doc){
        const label = findLeafWithText(doc, 'Min days after last sheet date', { exact:false });
        if(label){
          const cluster = label.closest && (label.closest('div') || label.closest('section') || label.parentElement);
          if(cluster){
            // Prefer input/select inside same cluster
            const ctl = cluster.querySelector && cluster.querySelector('input,select,textarea');
            if(ctl) return ctl;
          }
          // Try sibling/parent neighborhood
          const p = label.parentElement;
          if(p){
            const ctl2 = p.querySelector && p.querySelector('input,select,textarea');
            if(ctl2) return ctl2;
          }
        }
        // fallback: first numeric input on page (least reliable)
        const num = doc.querySelector('input[type="number"]') || doc.querySelector('input');
        return num || null;
      }

      function applyMinDaysToSource(value){
        if(!canAccessFrame()) return false;
        const doc = getDoc();
        const ctl = findMinDaysControl(doc);
        if(!ctl) return false;

        const v = String(value ?? '').trim();
        if(v === '') return false;

        try{
          ctl.focus && ctl.focus();
          if(ctl.tagName && ctl.tagName.toUpperCase() === 'SELECT'){
            // try select option matching value
            const opts = Array.from(ctl.options || []);
            const match = opts.find(o => String(o.value) === v || clean(o.textContent) === v);
            if(match) ctl.value = match.value;
          }else{
            ctl.value = v;
          }
          ctl.dispatchEvent(new Event('input', { bubbles:true }));
          ctl.dispatchEvent(new Event('change', { bubbles:true }));
          return true;
        }catch(e){
          return false;
        }
      }

      function extractMinDays(doc){
        const label = findLeafWithText(doc, 'Min days after last sheet date', { exact:false });
        if(label){
          let v = valueNearLabel(label);
          const num = (v || '').match(/-?\d+(\.\d+)?/);
          return num ? num[0] : (v || '');
        }
        const txt = clean(doc.body.innerText);
        const m = txt.match(/Min\s+days\s+after\s+last\s+sheet\s+date\s*[:\-—]?\s*([0-9]+(\.[0-9]+)?)/i);
        return m ? m[1] : '';
      }

      function extractTimePrice(doc){
        const heading = findHeadingContaining(doc, 'Next Extremum (prediction)');
        const boundary = heading ? findBoundaryHeading(doc, heading) : null;

        let time = '—';
        let price = '—';

        const timeLabel = findLeafWithText(doc, 'Time', { exact:true, withinStart: heading, withinEnd: boundary }) ||
                          findLeafWithText(doc, 'Time', { exact:true });
        const priceLabel = findLeafWithText(doc, 'Price', { exact:true, withinStart: heading, withinEnd: boundary }) ||
                           findLeafWithText(doc, 'Price', { exact:true });

        if(timeLabel) time = valueNearLabel(timeLabel) || '—';
        if(priceLabel) price = valueNearLabel(priceLabel) || '—';

        return { time: clean(time) || '—', price: clean(price) || '—' };
      }

      function updateUI({ time, price }){
        timeEl.textContent = time ?? '—';
        priceEl.textContent = price ?? '—';
      }

      function sendPrediction({ time, price }){
        post({ type:'prediction', method: METHOD, time: time ?? '—', price: price ?? '—', at: Date.now() });
      }

      function validMinDays(v){
        if(v === '' || v == null) return false;
        const n = Number(v);
        return Number.isFinite(n) && n >= 0;
      }

      async function clickAndPoll(){
        if(!canAccessFrame()){
          panelError('Cannot read source page (same-origin required).');
          return;
        }

        const doc = getDoc();
        const sourceBtn = findLoadPredictButton(doc);
        if(!sourceBtn){
          panelError('Could not find “Load & Predict” button on source page.');
          return;
        }

        // Ensure min-days pushed into the source before clicking
        const md = String(minDaysInput.value ?? '').trim();
        if(validMinDays(md)){
          const ok = applyMinDaysToSource(md);
          if(!ok){
            // not fatal; but warn
            setStatus('err', 'Min-days control not found in source');
          }
        }

        predictBtn.disabled = true;
        setStatus('warn', 'Running prediction…');

        const before = extractTimePrice(doc);
        try{ sourceBtn.click(); } catch(e){
          panelError('Failed to click source “Load & Predict” button.');
          return;
        }

        const start = Date.now();
        const TIMEOUT_MS = 16000;
        const INTERVAL_MS = 350;

        const timer = setInterval(() => {
          if(!canAccessFrame()){
            clearInterval(timer);
            panelError('Lost access to source page (same-origin issue).');
            return;
          }

          const d = getDoc();
          const now = extractTimePrice(d);
          updateUI(now);

          const changed = clean(now.time) !== clean(before.time) || clean(now.price) !== clean(before.price);
          const looksReady = clean(now.time) && clean(now.time) !== '—' && clean(now.price) && clean(now.price) !== '—';

          if(changed && looksReady){
            clearInterval(timer);
            setStatus('ok', 'Updated');
            predictBtn.disabled = false;
            sendPrediction(now);
            return;
          }

          if(Date.now() - start > TIMEOUT_MS){
            clearInterval(timer);
            setStatus('err', 'Timed out (no new values found)');
            predictBtn.disabled = false;
            sendPrediction(now);
          }
        }, INTERVAL_MS);
      }

      // Listen for parent broadcast: set_min_days
      window.addEventListener('message', (event) => {
        if(event.origin !== window.location.origin) return;
        const msg = event.data || {};
        if(msg.type === 'set_min_days'){
          const v = String(msg.value ?? '').trim();
          if(validMinDays(v)){
            minDaysInput.value = v;
            const ok = applyMinDaysToSource(v);
            setStatus(ok ? 'ok' : 'err', ok ? 'Min-days applied' : 'Min-days control not found');
          }
        }
      });

      // User edits local min-days (sync to parent + push to source)
      minDaysInput.addEventListener('change', () => {
        const v = String(minDaysInput.value ?? '').trim();
        if(!validMinDays(v)) return;
        const ok = applyMinDaysToSource(v);
        setStatus(ok ? 'ok' : 'err', ok ? 'Min-days applied' : 'Min-days control not found');
        post({ type:'min_days_changed', method: METHOD, value: v });
      });

      minDaysInput.addEventListener('keydown', (e) => {
        if(e.key === 'Enter'){
          minDaysInput.dispatchEvent(new Event('change', { bubbles:true }));
        }
      });

      // Load the source in hidden iframe (must be same-origin)
      sourceFrame.src = SOURCE_URL;

      sourceFrame.addEventListener('load', () => {
        setTimeout(() => {
          if(!canAccessFrame()){
            panelError('Same-origin blocked. Host this project on the SAME github.io domain as the source pages.');
            return;
          }

          setStatus('ok', 'Ready');
          predictBtn.disabled = false;

          // Try to auto-fill minDays from source once
          try{
            const v = extractMinDays(getDoc());
            if(v && v !== '—' && !minDaysInput.value){
              minDaysInput.value = v;
              post({ type:'min_days_detected', method: METHOD, value: v });
            }else if(v){
              post({ type:'min_days_detected', method: METHOD, value: v });
            }
          }catch(_){}

          // Initial time/price display
          updateUI(extractTimePrice(getDoc()));

          post({ type:'ready', method: METHOD });
        }, 250);
      });

      setTimeout(() => {
        if(statusText.textContent.toLowerCase().includes('loading')){
          panelError('Source page did not load (network / URL issue).');
        }
      }, 12000);

      predictBtn.addEventListener('click', clickAndPoll);
    })();
  </script>
</body>
</html>
