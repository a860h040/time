<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Method 1 Panel</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --hair:rgba(255,255,255,.10);
      --hair2:rgba(255,255,255,.08);
      --text:#eaf0ff;
      --muted:rgba(234,240,255,.72);
      --ok:#2bd07e; --warn:#ffd166; --err:#ff6b6b;
      --radius:16px;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:transparent; color:var(--text); }
    .panel{ padding:14px; display:flex; flex-direction:column; gap:12px; }
    .top{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .btn{
      appearance:none; border:1px solid rgba(90,160,255,.55);
      background:linear-gradient(180deg, rgba(90,160,255,.25), rgba(90,160,255,.10));
      color:var(--text); font-weight:800; letter-spacing:.2px;
      padding:10px 12px; border-radius:12px; cursor:pointer;
      transition:transform .08s ease; user-select:none; white-space:nowrap;
    }
    .btn:active{ transform:translateY(1px); }
    .btn[disabled]{ opacity:.55; cursor:not-allowed; }

    .pill{
      display:inline-flex; align-items:center; gap:8px; padding:7px 10px; border-radius:999px;
      border:1px solid var(--hair2); background:rgba(255,255,255,.04);
      color:var(--muted); font-size:12px; white-space:nowrap;
    }
    .dot{ width:8px;height:8px;border-radius:50%; background:var(--warn); box-shadow:0 0 0 4px rgba(255,209,102,.12); }
    .dot.ok{ background:var(--ok); box-shadow:0 0 0 4px rgba(43,208,126,.12); }
    .dot.err{ background:var(--err); box-shadow:0 0 0 4px rgba(255,107,107,.12); }

    .grid{
      display:grid; gap:10px; padding:10px;
      border:1px solid var(--hair); border-radius:var(--radius);
      background:rgba(255,255,255,.03);
    }
    .row{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:8px 8px; border-radius:12px;
      background:rgba(0,0,0,.12); border:1px solid rgba(255,255,255,.06);
    }
    .k{ font-size:12px; color:var(--muted); }
    .v{ font-size:13px; font-weight:800; color:rgba(234,240,255,.95); text-align:right; word-break:break-word; }

    .minInput{
      width:120px; border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.22); color:var(--text);
      padding:10px 10px; font-weight:800; outline:none; text-align:right;
    }
    .minInput:focus{
      border-color:rgba(90,160,255,.55);
      box-shadow:0 0 0 4px rgba(90,160,255,.14);
    }
    .hint{ font-size:11.5px; color:rgba(234,240,255,.60); line-height:1.35; }
    .hint a{ color:rgba(90,160,255,.95); text-decoration:none; }
    .hint a:hover{ text-decoration:underline; }

    #sourceFrame{
      position:absolute; left:-99999px; top:-99999px;
      width:1280px; height:720px; opacity:0; pointer-events:none; border:0;
    }
  </style>
</head>

<body>
  <div class="panel">
    <div class="top">
      <button class="btn" id="predictBtn" disabled>Load &amp; Predict</button>
      <div class="pill">
        <span class="dot" id="statusDot"></span>
        <span id="statusText">Loading source…</span>
      </div>
    </div>

    <div class="grid">
      <div class="row">
        <div class="k">Min days after last sheet date</div>
        <input id="minDaysInput" class="minInput" type="number" min="0" step="1" placeholder="e.g., 3" />
      </div>
      <div class="row"><div class="k">Time</div><div class="v" id="time">—</div></div>
      <div class="row"><div class="k">Price</div><div class="v" id="price">—</div></div>
    </div>

    <div class="hint">
      Source: <a href="https://a860h040.github.io/time/index1" target="_blank" rel="noopener">open Method 1 page</a>
    </div>
  </div>

  <iframe id="sourceFrame" title="Method 1 Source" src="about:blank"></iframe>

  <script>
    (function(){
      const METHOD = 'method1';
      const SOURCE_URL = 'https://a860h040.github.io/time/index1';

      const predictBtn = document.getElementById('predictBtn');
      const statusDot  = document.getElementById('statusDot');
      const statusText = document.getElementById('statusText');
      const minDaysInput = document.getElementById('minDaysInput');
      const timeEl  = document.getElementById('time');
      const priceEl = document.getElementById('price');
      const sourceFrame = document.getElementById('sourceFrame');

      function clean(s){ return String(s ?? '').replace(/\s+/g,' ').trim(); }
      function setStatus(state, text){
        statusText.textContent = text;
        statusDot.classList.remove('ok','err');
        if(state === 'ok') statusDot.classList.add('ok');
        if(state === 'err') statusDot.classList.add('err');
      }
      function post(msg){
        try{ window.parent.postMessage(msg, window.location.origin); }catch(_){}
      }
      function panelError(message){
        setStatus('err', message);
        predictBtn.disabled = true;
        post({ type:'panel_error', method: METHOD, message });
      }

      // IMPORTANT: must be same-origin
      const sameOrigin = (new URL(SOURCE_URL)).origin === window.location.origin;
      if(!sameOrigin){
        panelError(`Origin mismatch. This page is ${window.location.origin} but source is ${(new URL(SOURCE_URL)).origin}. Host on https://a860h040.github.io/...`);
        return;
      }

      function canAccessFrame(){
        try{ return !!(sourceFrame.contentDocument && sourceFrame.contentDocument.body); }
        catch(e){ return false; }
      }
      function getDoc(){ return sourceFrame.contentDocument; }

      // ---- Text-based extraction (very reliable) ----
      function getLines(doc){
        const raw = (doc && doc.body) ? doc.body.innerText : '';
        return raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      }

      function extractSection(lines){
        // choose the LAST occurrence of the Next Extremum section (pages can include duplicates)
        let start = -1;
        for(let i=0;i<lines.length;i++){
          if(lines[i].toLowerCase().includes('next extremum (prediction)')) start = i;
        }
        if(start < 0) return lines;

        const out = [];
        for(let i=start; i<Math.min(lines.length, start+100); i++){
          const t = lines[i].toLowerCase();
          if(i !== start && (t.includes('10-day price path') || t.startsWith('4)') || t.includes('chart'))) break;
          out.push(lines[i]);
        }
        return out;
      }

      function valueAfter(sectionLines, label){
        const L = label.toLowerCase();
        for(let i=0;i<sectionLines.length;i++){
          if(sectionLines[i].toLowerCase() === L){
            for(let j=i+1;j<sectionLines.length;j++){
              const v = sectionLines[j];
              const vl = v.toLowerCase();
              if([ 'type','time','price','consensus' ].includes(vl)) continue;
              return v;
            }
          }
        }
        // fallback "Label: value"
        for(const line of sectionLines){
          const m = line.match(new RegExp('^' + label + '\\s*[:\\-—]?\\s*(.+)$','i'));
          if(m && m[1]) return m[1].trim();
        }
        return '';
      }

      function extractTimePrice(doc){
        const lines = getLines(doc);
        const sec = extractSection(lines);
        return {
          time:  valueAfter(sec, 'Time')  || '—',
          price: valueAfter(sec, 'Price') || '—'
        };
      }

      function extractMinDaysText(doc){
        const lines = getLines(doc);
        const needle = 'min days after last sheet date';
        for(let i=0;i<lines.length;i++){
          if(lines[i].toLowerCase() === needle){
            for(let j=i+1;j<lines.length;j++){
              const v = lines[j];
              if(v) return v;
            }
          }
        }
        return '';
      }

      // ---- Find + set the Min Days control (scored heuristic) ----
      function scoreMinDaysControl(el){
        let s = 0;
        const id = (el.id || '').toLowerCase();
        const nm = (el.name || '').toLowerCase();
        const ph = (el.placeholder || '').toLowerCase();
        const al = (el.getAttribute('aria-label') || '').toLowerCase();
        const type = (el.type || '').toLowerCase();
        const txtParent = clean(el.parentElement ? el.parentElement.innerText : '').toLowerCase();

        if(type === 'number') s += 4;
        if(id.includes('min') && id.includes('day')) s += 10;
        if(nm.includes('min') && nm.includes('day')) s += 10;
        if(id.includes('days') || nm.includes('days')) s += 3;
        if(ph.includes('min days') || al.includes('min days')) s += 8;
        if(txtParent.includes('min days after last sheet date')) s += 12;
        return s;
      }

      function findMinDaysControl(doc){
        const inputs = Array.from(doc.querySelectorAll('input,select,textarea'));
        let best = null, bestScore = 0;
        for(const el of inputs){
          const sc = scoreMinDaysControl(el);
          if(sc > bestScore){
            bestScore = sc;
            best = el;
          }
        }
        return (bestScore >= 8) ? best : null; // require some confidence
      }

      function applyMinDaysToSource(value){
        if(!canAccessFrame()) return false;
        const doc = getDoc();
        const ctl = findMinDaysControl(doc);
        if(!ctl) return false;

        try{
          const v = String(value ?? '').trim();
          ctl.value = v;
          ctl.dispatchEvent(new Event('input', { bubbles:true }));
          ctl.dispatchEvent(new Event('change', { bubbles:true }));
          return true;
        }catch(e){
          return false;
        }
      }

      // ---- Find predict buttons (click them safely) ----
      function findPredictButtons(doc){
        const nodes = Array.from(doc.querySelectorAll('button,input[type="button"],input[type="submit"],a,[role="button"]'));
        const out = [];
        for(const el of nodes){
          const txt = clean(el.innerText || el.value || el.getAttribute('aria-label') || '');
          const tl  = txt.toLowerCase();
          if(tl.includes('load') && tl.includes('predict')) out.push(el);
        }
        return out;
      }

      function updateUI(v){
        timeEl.textContent = v.time ?? '—';
        priceEl.textContent = v.price ?? '—';
      }

      function sendPrediction(v){
        post({ type:'prediction', method: METHOD, time: v.time ?? '—', price: v.price ?? '—', at: Date.now() });
      }

      async function clickAndPoll(){
        if(!canAccessFrame()) return panelError('Cannot access source frame (unexpected).');

        const doc = getDoc();
        const buttons = findPredictButtons(doc);
        if(buttons.length === 0) return panelError('Could not find any “Load & Predict” buttons on source.');

        const md = String(minDaysInput.value ?? '').trim();
        if(md !== ''){
          const ok = applyMinDaysToSource(md);
          if(!ok){
            setStatus('err', 'Could not find Min-days input in source page');
          }
        }

        predictBtn.disabled = true;
        setStatus('warn', 'Running prediction…');

        const before = extractTimePrice(doc);

        // Click all candidates (some pages may have duplicate non-functional buttons)
        for(const b of buttons){
          try{ b.click(); }catch(_){}
        }

        const start = Date.now();
        const TIMEOUT = 20000;
        const TICK = 350;

        const timer = setInterval(() => {
          if(!canAccessFrame()){
            clearInterval(timer);
            panelError('Lost access to source page.');
            return;
          }

          const now = extractTimePrice(getDoc());
          updateUI(now);

          const changed = clean(now.time) !== clean(before.time) || clean(now.price) !== clean(before.price);
          const ready = clean(now.time) && now.time !== '—' && clean(now.price) && now.price !== '—';

          if(changed && ready){
            clearInterval(timer);
            setStatus('ok', 'Updated');
            predictBtn.disabled = false;
            sendPrediction(now);
            return;
          }

          if(Date.now() - start > TIMEOUT){
            clearInterval(timer);
            setStatus('err', 'Timed out (no new values)');
            predictBtn.disabled = false;
            sendPrediction(now);
          }
        }, TICK);
      }

      minDaysInput.addEventListener('change', () => {
        const v = String(minDaysInput.value ?? '').trim();
        if(v === '') return;
        const ok = applyMinDaysToSource(v);
        setStatus(ok ? 'ok' : 'err', ok ? 'Min-days applied' : 'Min-days not found in source');
      });

      sourceFrame.src = SOURCE_URL + '?_=' + Date.now();

      sourceFrame.addEventListener('load', () => {
        setTimeout(() => {
          if(!canAccessFrame()) return panelError('Same-origin blocked (must host on https://a860h040.github.io/...).');

          setStatus('ok', 'Ready');
          predictBtn.disabled = false;

          // Prefill min-days from source (if shown as text)
          const mdText = extractMinDaysText(getDoc());
          if(mdText && mdText !== '—' && !minDaysInput.value){
            const m = mdText.match(/-?\d+(\.\d+)?/);
            if(m) minDaysInput.value = m[0];
          }

          updateUI(extractTimePrice(getDoc()));
          post({ type:'ready', method: METHOD });
        }, 300);
      });

      predictBtn.addEventListener('click', clickAndPoll);
    })();
  </script>
</body>
</html>
